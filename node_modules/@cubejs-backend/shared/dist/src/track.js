"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.track = exports.getAnonymousId = void 0;
const crypto_1 = __importDefault(require("crypto"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const node_machine_id_1 = require("node-machine-id");
const errors_1 = require("./errors");
let flushPromise = null;
let trackEvents = [];
async function flush(toFlush, retries = 10) {
    if (!toFlush) {
        toFlush = trackEvents;
        trackEvents = [];
    }
    if (!toFlush.length) {
        return;
    }
    try {
        const sentAt = new Date().toJSON();
        const result = await node_fetch_1.default('https://track.cube.dev/track', {
            method: 'post',
            body: JSON.stringify(toFlush.map(r => (Object.assign(Object.assign({}, r), { sentAt })))),
            headers: { 'Content-Type': 'application/json' },
        });
        if (result.status !== 200 && retries > 0) {
            // eslint-disable-next-line consistent-return
            return flush(toFlush, retries - 1);
        }
        // console.log(await result.json());
    }
    catch (e) {
        if (retries > 0) {
            // eslint-disable-next-line consistent-return
            return flush(toFlush, retries - 1);
        }
        errors_1.internalExceptions(e);
    }
}
let anonymousId = 'unknown';
try {
    anonymousId = node_machine_id_1.machineIdSync();
}
catch (e) {
    errors_1.internalExceptions(e);
}
function getAnonymousId() {
    return anonymousId;
}
exports.getAnonymousId = getAnonymousId;
async function track(opts) {
    trackEvents.push(Object.assign(Object.assign({}, opts), { id: crypto_1.default.randomBytes(16).toString('hex'), clientTimestamp: new Date().toJSON(), platform: process.platform, nodeVersion: process.version, anonymousId }));
    const currentPromise = (flushPromise || Promise.resolve()).then(() => flush()).then(() => {
        if (currentPromise === flushPromise) {
            flushPromise = null;
        }
    });
    flushPromise = currentPromise;
    return flushPromise;
}
exports.track = track;
//# sourceMappingURL=track.js.map