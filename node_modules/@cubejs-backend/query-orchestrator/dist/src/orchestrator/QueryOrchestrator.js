"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryOrchestrator = void 0;
const ramda_1 = __importDefault(require("ramda"));
const QueryCache_1 = require("./QueryCache");
const PreAggregations_1 = require("./PreAggregations");
const RedisPool_1 = require("./RedisPool");
class QueryOrchestrator {
    constructor(redisPrefix, driverFactory, logger, options) {
        options = options || {};
        this.redisPrefix = redisPrefix;
        this.driverFactory = driverFactory;
        this.logger = logger;
        const { externalDriverFactory } = options;
        const cacheAndQueueDriver = options.cacheAndQueueDriver || process.env.CUBEJS_CACHE_AND_QUEUE_DRIVER || (process.env.NODE_ENV === 'production' || process.env.REDIS_URL ? 'redis' : 'memory');
        if (cacheAndQueueDriver !== 'redis' && cacheAndQueueDriver !== 'memory') {
            throw new Error('Only \'redis\' or \'memory\' are supported for cacheAndQueueDriver option');
        }
        const redisPool = cacheAndQueueDriver === 'redis' ? new RedisPool_1.RedisPool() : undefined;
        this.redisPool = redisPool;
        this.queryCache = new QueryCache_1.QueryCache(this.redisPrefix, this.driverFactory, this.logger, Object.assign({ externalDriverFactory,
            cacheAndQueueDriver,
            redisPool }, options.queryCacheOptions));
        this.preAggregations = new PreAggregations_1.PreAggregations(this.redisPrefix, this.driverFactory, this.logger, this.queryCache, Object.assign({ externalDriverFactory,
            cacheAndQueueDriver,
            redisPool }, options.preAggregationsOptions));
        this.rollupOnlyMode = options.rollupOnlyMode;
    }
    async fetchQuery(queryBody) {
        return this.preAggregations.loadAllPreAggregationsIfNeeded(queryBody)
            .then(async (preAggregationsTablesToTempTables) => {
            const usedPreAggregations = ramda_1.default.fromPairs(preAggregationsTablesToTempTables);
            if (this.rollupOnlyMode && Object.keys(usedPreAggregations).length === 0) {
                throw new Error('No pre-aggregation exists for that query');
            }
            if (!queryBody.query) {
                return {
                    usedPreAggregations
                };
            }
            const result = await this.queryCache.cachedQueryResult(queryBody, preAggregationsTablesToTempTables);
            return Object.assign(Object.assign({}, result), { usedPreAggregations });
        });
    }
    async queryStage(queryBody) {
        const queue = this.preAggregations.getQueue();
        const preAggregationsQueryStageState = await queue.fetchQueryStageState();
        const pendingPreAggregationIndex = (await Promise.all((queryBody.preAggregations || [])
            .map(p => queue.getQueryStage(PreAggregations_1.PreAggregations.preAggregationQueryCacheKey(p), 10, preAggregationsQueryStageState)))).findIndex(p => !!p);
        if (pendingPreAggregationIndex === -1) {
            return this.queryCache.getQueue().getQueryStage(QueryCache_1.QueryCache.queryCacheKey(queryBody));
        }
        const preAggregation = queryBody.preAggregations[pendingPreAggregationIndex];
        const preAggregationStage = await queue.getQueryStage(PreAggregations_1.PreAggregations.preAggregationQueryCacheKey(preAggregation), undefined, preAggregationsQueryStageState);
        if (!preAggregationStage) {
            return undefined;
        }
        const stageMessage = `Building pre-aggregation ${pendingPreAggregationIndex + 1}/${queryBody.preAggregations.length}`;
        if (preAggregationStage.stage.indexOf('queue') !== -1) {
            return Object.assign(Object.assign({}, preAggregationStage), { stage: `${stageMessage}: ${preAggregationStage.stage}` });
        }
        else {
            return Object.assign(Object.assign({}, preAggregationStage), { stage: stageMessage });
        }
    }
    resultFromCacheIfExists(queryBody) {
        return this.queryCache.resultFromCacheIfExists(queryBody);
    }
    async cleanup() {
        if (this.redisPool) {
            await this.redisPool.cleanup();
        }
    }
}
exports.QueryOrchestrator = QueryOrchestrator;
//# sourceMappingURL=QueryOrchestrator.js.map