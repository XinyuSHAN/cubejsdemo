"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisPool = void 0;
const generic_pool_1 = __importDefault(require("generic-pool"));
const RedisFactory_1 = require("./RedisFactory");
class RedisPool {
    constructor(options) {
        options = options || {};
        const defaultMin = process.env.CUBEJS_REDIS_POOL_MIN ? parseInt(process.env.CUBEJS_REDIS_POOL_MIN, 10) : 2;
        const defaultMax = process.env.CUBEJS_REDIS_POOL_MAX ? parseInt(process.env.CUBEJS_REDIS_POOL_MAX, 10) : 1000;
        const min = (typeof options.poolMin !== 'undefined') ? options.poolMin : defaultMin;
        const max = (typeof options.poolMax !== 'undefined') ? options.poolMax : defaultMax;
        const create = options.createClient || (() => RedisFactory_1.createRedisClient(process.env.REDIS_URL));
        const destroy = options.destroyClient || (client => client.end(true));
        const opts = {
            min,
            max,
            acquireTimeoutMillis: 5000,
            idleTimeoutMillis: 5000,
            evictionRunIntervalMillis: 5000
        };
        if (max > 0) {
            this.pool = generic_pool_1.default.createPool({ create, destroy }, opts);
        }
        else {
            // fallback to un-pooled behavior if pool max is 0
            this.create = create;
        }
    }
    async getClient() {
        if (this.pool) {
            return this.pool.acquire();
        }
        else {
            return this.create();
        }
    }
    release(client) {
        if (this.pool) {
            this.pool.release(client);
        }
        else if (client) {
            client.quit();
        }
    }
    async cleanup() {
        if (this.pool) {
            await this.pool.drain();
            this.pool.clear();
        }
    }
}
exports.RedisPool = RedisPool;
//# sourceMappingURL=RedisPool.js.map